1.线程一共有5中状态
	新建（new）：线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。
	就绪（runnable）：例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行
	运行（running）：线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态
	阻塞（blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行
		等待阻塞：wait()
		同步阻塞：synchronized
		其他阻塞：sleep()，join()，发出了I/O请求
	死亡（dead）：线程执行完了或者因异常退出了run()方法
---------------------
2.start() 和 run()的区别
	start() : 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。
		start()实际上是通过本地方法start0()启动线程的。而start0()会新运行一个线程，新线程会调用run()方法
	run()   : run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！
---------------------
3.synchronized
	每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。
		第一：当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞
		第二：当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块
		第三：当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞
	实例锁 和 全局锁
		实例锁 ： 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。实例锁对应的就是synchronized关键字
		全局锁 ： 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。 全局锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）
----------------------
4.线程的等待与唤醒
	wait(), notify(), notifyAll()
		notify(): 唤醒在此对象监视器上等待的单个线程。
		notifyAll(): 唤醒在此对象监视器上等待的所有线程。
		wait(): 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。
		wait(long timeout): 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。
		wait(long timeout, int nanos): 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。
	yield()（不会释放同步锁）
		yield()：作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！
----------------------
5.线程的终止方式
	interrupt()
		本线程中断自己是被允许的；
		其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。
		如果本线程是处于(非同步)阻塞状态：调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。
		如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。
		如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。
		中断一个“已终止的线程”不会产生任何操作。




























		









	wait(), notify(), notifyAll(
			
		
		
		
		
		
		
		
		
		